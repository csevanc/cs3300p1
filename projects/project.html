<html>
    <head>
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
        <!-- <link rel="stylesheet" type="text/css" href="../css/normalize.css">
        <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
        <link rel="stylesheet" type="text/css" href="../css/custom-style.css"> -->
        <script src="https://d3js.org/d3.v7.min.js"></script>  
        
        <style>
            .gridlines line {
                stroke: #bbb;
            }
            
            .gridlines .domain {
                stroke: none;
            }
        </style>
        
        <title>INFO 3300 - Project 1 - Justin Wong (jsw345)</title>
    </head>
    <body>
        <h3>INFO3300 - Project 1- Justin Wong (jsw345)</h3>
        <p id="p1">
            <svg id="lineChart" height="600" width="1500"></svg>
            <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top:30px" ></svg>

            <script>
                // credited in codesource.js
                function drawLegend(legendSelector, legendColorScale) {
    
                // This code should adapt to a variety of different kinds of color scales
                //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS
                
                // Shrink legend bar by 5 px inwards from sides of SVG
                const offsets = { width: 50,
                                top: 35,
                                bottom: 24 }; 
                // Number of integer 'pixel steps' to draw when showing continuous scales
                //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
                const stepSize = 4; 
                // Extend the minmax by 0% in either direction to expose more features by default
                const minMaxExtendPercent = 0;
                
                
                const legend = d3.select(legendSelector);
                const legendHeight = legend.attr("height");
                const legendBarWidth = legend.attr("width") - (offsets.width * 2);
                legend.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${offsets.width}, ${offsets.top/2-5})`)
                       .append("text") 
                       .text("Less CO2 Emissions")
                    //    .attr("text-anchor", "middle")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 15)
                legend.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${legendBarWidth+offsets.width}, ${offsets.top/2-5})`)
                       .append("text") 
                       .text("More CO2 Emissions")
                       .attr("text-anchor", "end")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 15)
                const legendMinMax = d3.extent(legendColorScale.domain()); 
                            // recover the min and max values from most kinds of numeric scales
                const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
                const barHeight = legendHeight - offsets.top - offsets.bottom;     
                
                // In this case the "data" are pixels, and we get numbers to use in colorScale
                // Use this to make axis labels
                let barScale = d3.scaleLinear().domain([legendMinMax[0]-minMaxExtension,
                                                        legendMinMax[1]+minMaxExtension])
                                                .range([0,legendBarWidth]);
                let barAxis = d3.axisBottom(barScale).ticks(10).tickFormat( d => String(d).substring(0, 2) + "M");
                
                // Place for bar slices to live
                let bar = legend.append("g")
                                .attr("class", "legend colorbar")
                                .attr("transform", `translate(${offsets.width},${offsets.top})`)
                
                // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******
                
                // Check if we're using a binning scale - if so, we make blocks of color
                if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                // Get the thresholds
                let thresholds = [];
                if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                else { thresholds = legendColorScale.quantiles() }
                
                const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];
                
                // Use the quantile breakpoints plus the min and max of the scale as tick values
                barAxis.tickValues(barThresholds);
                
                // Draw rectangles between the threshold segments
                for (let i=0; i<barThresholds.length-1; i++) {
                    let dataStart = barThresholds[i];
                    let dataEnd = barThresholds[i+1];
                    let pixelStart = barAxis.scale()(dataStart);
                    let pixelEnd = barAxis.scale()(dataEnd);
                    
                    bar.append("rect")
                        .attr("x", pixelStart)
                        .attr("y", 0)
                        .attr("width", pixelEnd - pixelStart )
                        .attr("height", barHeight)
                        .style("fill", legendColorScale( (dataStart + dataEnd) / 2.0 ) ); 
                }
                }
                // Else if we have a continuous / roundable scale
                //  In an ideal world you might construct a custom gradient mapped to the scale
                //  For this one, we use a hack of making stepped rects
                else if (legendColorScale.hasOwnProperty('rangeRound')) {
                // NOTE: The barAxis may round min and max values to make them pretty
                // ** This also means there is a risk of the legend going beyond scale bounds
                // We need to use the barAxis min and max just to be sure the bar is complete
                //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                // ** We also need to create patches for the scale if the labels exceed bounds
                //     (floating point comparisons risky for small data ranges,but not a big deal
                //      because patches will be indistinguishable from actual scale bottom)
                // It's likely that scale clamping will actually do this for us elegantly
                // ...but better to be safer and patch the regions anyways
                
                for (let i=0; i<legendBarWidth; i=i+stepSize) {
                    
                    let center = i+(stepSize/2);
                    let dataCenter = barAxis.scale().invert( center );
                    
                    // below normal scale bounds
                    if ( dataCenter < legendMinMax[0] ) { 
                    bar.append("rect")
                        .attr("x", i)
                        .attr("y", 0)
                        .attr("width", stepSize)
                        .attr("height",barHeight)
                        .style("fill", legendColorScale( legendMinMax[0] ) ); 
                    }
                    // within normal scale bounds
                    else if ( dataCenter < legendMinMax[1] ) {
                        bar.append("rect")
                        .attr("x", i)
                        .attr("y", 0)
                        .attr("width", stepSize)
                        .attr("height",barHeight)
                        .style("fill", legendColorScale( dataCenter ) ); 
                    }
                    // above normal scale bounds
                    else {
                        bar.append("rect")
                        .attr("x", i)
                        .attr("y", 0)
                        .attr("width", stepSize)
                        .attr("height",barHeight)
                        .style("fill", legendColorScale( legendMinMax[1] ) ); 
                    }
                    
                }
                }
                // Otherwise we have a nominal scale
                else {
                let nomVals = legendColorScale.domain().sort();
                
                // Use a scaleBand to make blocks of color and simple labels
                let barScale = d3.scaleBand().domain(nomVals)
                                                .range([0,legendBarWidth])
                                                .padding(0.05);
                barAxis.scale(barScale);
                
                // Draw rectangles for each nominal entry
                nomVals.forEach( d => {
                    bar.append("rect")
                        .attr("x", barScale(d) )
                        .attr("y", 0)
                        .attr("width", barScale.bandwidth() )
                        .attr("height", barHeight)
                        .style("fill", legendColorScale( d ) );
                });
                }
                // DONE w/SWITCH
                
                // Finally, draw legend labels
                legend.append("g")
                    .attr("class", "legend axis")
                    .attr("transform",`translate(${offsets.width},${offsets.top+barHeight+5})`)
                    .call(barAxis);
                
                }
                d3.csv('Global CO2 Emissions Per Year.csv').then( (data) => { 
                    let svg = d3.select("svg#lineChart");
                    const height = svg.attr("height");
                    const width = svg.attr("width");
                    const margins = {top: 70, right: 10, bottom: 80, left: 110};
                    const chartHeight = height - margins.top - margins.bottom;
                    const chartWidth = width - margins.left - margins.right;
                    let chartArea = svg.append('g')
                                       .attr("transform", `translate(${margins.left}, ${margins.top})`)

                    let sum = 0;
                    data.reverse();
                    data.forEach( (d) => {
                        // will find total percent increases from 1976
                        let currPercent = d['CO2 Emissions Change'];
                        currPercent = currPercent.substring(0, currPercent.length - 1);
                        sum += Number(currPercent);
                        d['Absolute CO2 Change'] = sum;
                        d['Fossil CO2 Emissions (tons) Number'] = Number(d['Fossil CO2 Emissions (tons)'].replace(/,/g,''));
                    })

                    let yearExtent = d3.extent(data, d => d['Year'])
                    let changeExtent = d3.extent(data, d => d['Absolute CO2 Change'])
                    // console.log(data)
                    let CO2Extent = d3.extent(data, d => d['Fossil CO2 Emissions (tons) Number'])
                    // console.log(CO2Extent)
                    let xScale = d3.scaleLinear()
                                   .domain(yearExtent)
                                   .range([0, chartWidth])
                    let yScale = d3.scaleLinear()
                                   .domain(CO2Extent)
                                   .range([chartHeight, 0])

                    // let leftAxis = d3.axisLeft(yScale).tickFormat(x => x + "%")
                    // let leftAxis = d3.axisLeft(yScale)
                    let leftAxis = d3.axisLeft(yScale).tickFormat(x => String(x).substring(0, 2) + "M")
                    svg.append("g")
                       .attr("transform", `translate(${margins.left-10}, ${margins.top})`)
                       .call(leftAxis)

                    let leftGridlines = d3.axisLeft(yScale).tickFormat("").tickSize(-chartWidth-10)
                    svg.append("g")
                       .attr("class", "gridlines") // space in class, get two different classes
                       .attr("transform", `translate(${margins.left-10}, ${margins.top})`)
                       .call(leftGridlines)
                    
                    let bottomAxis = d3.axisBottom(xScale).tickFormat(x => Number(x)) // .ticks(data.length)
                    svg.append("g")
                       .attr("transform", `translate(${margins.left}, ${margins.top+chartHeight+30})`)
                       .call(bottomAxis)

                    let bottomGridlines = d3.axisBottom(xScale).tickFormat("").tickSize(-chartHeight-10)
                    svg.append("g")
                       .attr("class", "gridlines") // space in class, get two different classes
                       .attr("transform", `translate(${margins.left}, ${margins.top+chartHeight+30})`)
                       .call(bottomGridlines)

                    chartArea.selectAll("text#from1976").data(data)
                             .join("text")
                             .attr("class", "from1976")
                             .attr("x", d => xScale(d['Year']))
                             .attr("y", d => yScale(d['Fossil CO2 Emissions (tons) Number']) - 15)
                             .attr("text-anchor", "middle")
                             .attr("font-size", "10px")
                             .text(d => Math.round(d['Absolute CO2 Change']) + "%") 
                             

                    // chartArea.selectAll("text#yearToYear").data(data)
                    //          .join("text")
                    //          .attr("class", "yearToYear")
                    //          .attr("x", d => xScale(d['Year']))
                    //          .attr("y", d => yScale(d['Fossil CO2 Emissions (tons) Number']) + 25)
                    //          .attr("text-anchor", "middle")
                    //          .attr("font-size", "10px")
                    //          .text(d => d['CO2 Emissions Change'].substring(0,d['CO2 Emissions Change'].indexOf(".")+2) + "%")
                
                    // chartArea.selectAll("line").data(data)
                    //          .join("line")
                    //          .attr("x1", d => xScale(d['Year']) )
                    //          .attr("y1", height-margins.bottom)
                    //          .attr("x2", d => xScale(d['Year']) )
                    //         //  .attr("y2", d => yScale(d['Absolute CO2 Change']))
                    //          .attr("y2", d => yScale(d['Fossil CO2 Emissions (tons) Number']))
                    //          .style("stroke", "#5555F0")
                    //          .style("stroke-width", 10);

                    // credited in codesource.js
                    chartArea.append("linearGradient")
                             .attr("id", "line-gradient")
                             .attr("gradientUnits", "userSpaceOnUse")
                             .attr("x1", 0)
                             .attr("y1", yScale(CO2Extent[0]))
                             .attr("x2", 0)
                             .attr("y2", yScale(CO2Extent[1]))
                             .selectAll("stop")
                             .data([
                             {offset: "0%", color: "#58eb34"},
                             {offset: "100%", color: "red"} // gray: #525451, maroon: #800000, red, pay attention to accessibility
                             ])
                             .enter().append("stop")
                                    .attr("offset", function(d) { return d.offset; })
                                    .attr("stop-color", function(d) { return d.color; });

                    let lineGen = d3.line()
                                    .x(d => xScale( d['Year'] ))
                                    .y(d => yScale(d['Fossil CO2 Emissions (tons) Number']))
                                    .curve(d3.curveMonotoneX)
                    
                    chartArea.append("path")
                             .datum(data)
                             .attr("class", "line")
                             .attr("fill", "none")
                             .attr("stroke", "url(#line-gradient)")
                             .attr("stroke-width", 3)
                             .attr("d", d => lineGen(d))

                    chartArea.selectAll("circle").data(data)
                             .join("circle")
                             .attr("cx", d => xScale(d['Year']))
                             .attr("cy", d => yScale(d['Fossil CO2 Emissions (tons) Number']))
                             .attr("fill", "blue")
                             .attr("r", 3)

                    chartArea.raise()

                    svg.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${margins.left/2-20}, ${height/2}), rotate(-90)`)
                       .append("text") 
                       .text("Fossil CO2 Emissions (tons)")
                       .attr("text-anchor", "middle")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 20)
                    
                    svg.append("g")
                       .attr("class", "text") // space in class, get two different classes
                       .attr("transform", `translate(${width/2}, ${height-margins.bottom/2+30})`)
                       .append("text") 
                       .text("Year")
                       .attr("text-anchor", "middle")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 20)

                    svg.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${width/2}, ${margins.top/2})`)
                       .append("text") 
                       .text("Fossil CO2 Emissions (tons) from 1977 to 2022")
                       .attr("text-anchor", "middle")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 25)
                    
                     svg.append("g")
                       .attr("class", "text")
                       .attr("transform", `translate(${margins.left/2-20}, ${height-7})`)
                       .append("text") 
                       .text("*Percent difference is calculated using the CO2 emissions from 1976 as a baseline")
                    //    .attr("text-anchor", "middle")
                       .attr("dominant-baseline", "middle")
                       .style("fill", "black")
                       .style("font-family", "Monaco")
                       .style("font-size", 14)


                    const colorScale = d3.scaleSequential()
                                         .domain(CO2Extent)
                                         .interpolator(d3.interpolateRgb("#58eb34", "red"))
                
                    drawLegend("#colorLegend", colorScale);      
                })
            </script>
        </p>
    </body>
</html>