<html>

</html>

<head>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }
    </style>

    <title>INFO 3300 - Project 1 - Justin Wong (jsw345)</title>
</head>

<body>
    <h3>INFO3300 - Project 1- Justin Wong (jsw345)</h3>
    <p id="p1">
        <svg id="lineChart" height="600" width="1500"></svg>
        <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top:30px"></svg>

        <script>
            // below code credited in codesource.js
            // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

            function drawLegend(legendSelector, legendColorScale) {
                // This code should adapt to a variety of different kinds of color scales
                //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS

                // Shrink legend bar by 5 px inwards from sides of SVG
                const offsets = {
                    width: 50,
                    top: 35,
                    bottom: 24
                };
                // Number of integer 'pixel steps' to draw when showing continuous scales
                // Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
                const stepSize = 4;
                // Extend the minmax by 0% in either direction to expose more features by default
                const minMaxExtendPercent = 0;


                const legend = d3.select(legendSelector);
                const legendHeight = legend.attr("height");
                const legendBarWidth = legend.attr("width") - (offsets.width * 2);
                // add text to top left of color scale legend to say "Less CO2 Emissions"
                legend.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${offsets.width}, ${offsets.top / 2 - 5})`)
                    .append("text")
                    .text("Less CO2 Emissions")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 15)
                // add text to top right of color scale legend to say "More CO2 Emissions"
                legend.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${legendBarWidth + offsets.width}, ${offsets.top / 2 - 5})`)
                    .append("text")
                    .text("More CO2 Emissions")
                    .attr("text-anchor", "end")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 15)
                const legendMinMax = d3.extent(legendColorScale.domain());
                // recover the min and max values from most kinds of numeric scales
                const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
                const barHeight = legendHeight - offsets.top - offsets.bottom;

                // In this case the "data" are pixels, and we get numbers to use in colorScale
                // Use this to make axis labels
                let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
                legendMinMax[1] + minMaxExtension])
                    .range([0, legendBarWidth]);
                let barAxis = d3.axisBottom(barScale).ticks(10).tickFormat(d => String(d).substring(0, 2) + "M");

                // Place for bar slices to live
                let bar = legend.append("g")
                    .attr("class", "legend colorbar")
                    .attr("transform", `translate(${offsets.width},${offsets.top})`)

                // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

                // Check if we're using a binning scale - if so, we make blocks of color
                if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                    // Get the thresholds
                    let thresholds = [];
                    if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                    else { thresholds = legendColorScale.quantiles() }

                    const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                    // Use the quantile breakpoints plus the min and max of the scale as tick values
                    barAxis.tickValues(barThresholds);

                    // Draw rectangles between the threshold segments
                    for (let i = 0; i < barThresholds.length - 1; i++) {
                        let dataStart = barThresholds[i];
                        let dataEnd = barThresholds[i + 1];
                        let pixelStart = barAxis.scale()(dataStart);
                        let pixelEnd = barAxis.scale()(dataEnd);

                        bar.append("rect")
                            .attr("x", pixelStart)
                            .attr("y", 0)
                            .attr("width", pixelEnd - pixelStart)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale((dataStart + dataEnd) / 2.0));
                    }
                }
                // Else if we have a continuous / roundable scale
                //  In an ideal world you might construct a custom gradient mapped to the scale
                //  For this one, we use a hack of making stepped rects
                else if (legendColorScale.hasOwnProperty('rangeRound')) {
                    // NOTE: The barAxis may round min and max values to make them pretty
                    // ** This also means there is a risk of the legend going beyond scale bounds
                    // We need to use the barAxis min and max just to be sure the bar is complete
                    //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                    // ** We also need to create patches for the scale if the labels exceed bounds
                    //     (floating point comparisons risky for small data ranges,but not a big deal
                    //      because patches will be indistinguishable from actual scale bottom)
                    // It's likely that scale clamping will actually do this for us elegantly
                    // ...but better to be safer and patch the regions anyways

                    for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                        let center = i + (stepSize / 2);
                        let dataCenter = barAxis.scale().invert(center);

                        // below normal scale bounds
                        if (dataCenter < legendMinMax[0]) {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(legendMinMax[0]));
                        }
                        // within normal scale bounds
                        else if (dataCenter < legendMinMax[1]) {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(dataCenter));
                        }
                        // above normal scale bounds
                        else {
                            bar.append("rect")
                                .attr("x", i)
                                .attr("y", 0)
                                .attr("width", stepSize)
                                .attr("height", barHeight)
                                .style("fill", legendColorScale(legendMinMax[1]));
                        }

                    }
                }
                // Otherwise we have a nominal scale
                else {
                    let nomVals = legendColorScale.domain().sort();

                    // Use a scaleBand to make blocks of color and simple labels
                    let barScale = d3.scaleBand().domain(nomVals)
                        .range([0, legendBarWidth])
                        .padding(0.05);
                    barAxis.scale(barScale);

                    // Draw rectangles for each nominal entry
                    nomVals.forEach(d => {
                        bar.append("rect")
                            .attr("x", barScale(d))
                            .attr("y", 0)
                            .attr("width", barScale.bandwidth())
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(d));
                    });
                }
                // DONE w/SWITCH

                // Finally, draw legend labels
                legend.append("g")
                    .attr("class", "legend axis")
                    .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
                    .call(barAxis);

            }

            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // above credited in codesource.js

            d3.csv('Global CO2 Emissions Per Year.csv').then((data) => {
                let svg = d3.select("svg#lineChart");

                // setting margins and chart area
                const height = svg.attr("height");
                const width = svg.attr("width");
                const margins = { top: 70, right: 10, bottom: 80, left: 110 };
                const chartHeight = height - margins.top - margins.bottom;
                const chartWidth = width - margins.left - margins.right;
                let chartArea = svg.append('g')
                    .attr("transform", `translate(${margins.left}, ${margins.top})`)

                // preprocessing data
                let sum = 0;
                data.reverse();
                data.forEach((d) => {
                    // will find total percent increase from 1976 (use 1976 as a baseline)
                    let currPercent = d['CO2 Emissions Change']
                    currPercent = currPercent.substring(0, currPercent.length - 1);
                    sum += Number(currPercent);
                    d['Absolute CO2 Change'] = sum;
                    // convert CO2 emissions type String into type Number
                    d['Fossil CO2 Emissions (tons) Number'] = Number(d['Fossil CO2 Emissions (tons)'].replace(/,/g, ''));
                })

                // data extents and scales
                let yearExtent = d3.extent(data, d => d['Year'])
                let CO2Extent = d3.extent(data, d => d['Fossil CO2 Emissions (tons) Number'])
                let xScale = d3.scaleLinear()
                    .domain(yearExtent)
                    .range([0, chartWidth])
                let yScale = d3.scaleLinear()
                    .domain(CO2Extent)
                    .range([chartHeight, 0])

                // creating functions for axes/gridlines and drawing axes and gridlines
                let leftAxis = d3.axisLeft(yScale).tickFormat(x => String(x).substring(0, 2) + "M")
                svg.append("g")
                    .attr("transform", `translate(${margins.left - 10}, ${margins.top})`)
                    .call(leftAxis)

                let leftGridlines = d3.axisLeft(yScale).tickFormat("").tickSize(-chartWidth - 10)
                svg.append("g")
                    .attr("class", "gridlines")
                    .attr("transform", `translate(${margins.left - 10}, ${margins.top})`)
                    .call(leftGridlines)

                let bottomAxis = d3.axisBottom(xScale).tickFormat(x => Number(x))
                svg.append("g")
                    .attr("transform", `translate(${margins.left}, ${margins.top + chartHeight + 30})`)
                    .call(bottomAxis)

                let bottomGridlines = d3.axisBottom(xScale).tickFormat("").tickSize(-chartHeight - 10)
                svg.append("g")
                    .attr("class", "gridlines")
                    .attr("transform", `translate(${margins.left}, ${margins.top + chartHeight + 30})`)
                    .call(bottomGridlines)

                // below code credited in codesource.js
                // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

                // setting up color gradient for line in line graph
                chartArea.append("linearGradient")
                    .attr("id", "line-gradient-emissions")
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", 0)
                    .attr("y1", yScale(CO2Extent[0]))
                    .attr("x2", 0)
                    .attr("y2", yScale(CO2Extent[1]))
                    .selectAll("stop")
                    .data([
                        { offset: "0%", color: "#58eb34" },
                        { offset: "100%", color: "red" }
                    ])
                    .enter().append("stop")
                    .attr("offset", function (d) { return d.offset; })
                    .attr("stop-color", function (d) { return d.color; });

                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // above credited in codesource.js                                    

                // draw line in line graph
                let lineGen = d3.line()
                    .x(d => xScale(d['Year']))
                    .y(d => yScale(d['Fossil CO2 Emissions (tons) Number']))
                    .curve(d3.curveMonotoneX)

                chartArea.append("path")
                    .datum(data)
                    .attr("class", "line")
                    .attr("fill", "none")
                    .attr("stroke", "url(#line-gradient-emissions)")
                    .attr("stroke-width", 3)
                    .attr("d", d => lineGen(d))

                // draw datapoint circles in graph
                chartArea.selectAll("circle").data(data)
                    .join("circle")
                    .attr("cx", d => xScale(d['Year']))
                    .attr("cy", d => yScale(d['Fossil CO2 Emissions (tons) Number']))
                    .attr("fill", "blue")
                    .attr("r", 3)

                // add specific info/text about anomalies/events in datapoints (COVID and Great Recession)
                chartArea.selectAll("text#events").data(data)
                    .join("text")
                    .attr("x", d => xScale(d['Year']))
                    .attr("y", d => yScale(d['Fossil CO2 Emissions (tons) Number']) + 20)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .style("font-weight", "bold")
                    .text(d => d['Year'] == 2020 ? "Covid-19 Pandemic" : 
                            (d['Year'] == 2009 ? "End of Great Recession" : (
                                d['Year'] == 1982 ? "Early 1980s Recession" : ""
                         )));

                // add percent change label above data points
                chartArea.selectAll("text#from1976").data(data)
                    .join("text")
                    .attr("class", "from1976")
                    .attr("x", d => xScale(d['Year']))
                    .attr("y", d => yScale(d['Fossil CO2 Emissions (tons) Number']) - 15)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .text(d => Math.round(d['Absolute CO2 Change']) + "%")

                chartArea.raise()

                // y-label
                svg.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${margins.left / 2 - 20}, ${height / 2}), rotate(-90)`)
                    .append("text")
                    .text("Fossil CO2 Emissions (tons)")
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 20)

                // x-label
                svg.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${width / 2}, ${height - margins.bottom / 2 + 15})`)
                    .append("text")
                    .text("Year")
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 20)

                // title
                svg.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${width / 2}, ${margins.top / 2})`)
                    .append("text")
                    .text("Fossil CO2 Emissions (tons) from 1977 to 2022")
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 25)

                // explanation label at bottom left of graph
                svg.append("g")
                    .attr("class", "text")
                    .attr("transform", `translate(${margins.left / 2 - 20}, ${height - 7})`)
                    .append("text")
                    .text("*Percentages represent the percent increase in CO2 emissions for a specific year compared to 1976")
                    .attr("dominant-baseline", "middle")
                    .style("fill", "black")
                    .style("font-family", "Monaco")
                    .style("font-size", 14)

                // color scale for legend
                const colorScale = d3.scaleSequential()
                    .domain(CO2Extent)
                    .interpolator(d3.interpolateRgb("#58eb34", "red"))

                // drawing legend
                drawLegend("#colorLegend", colorScale);
            })
        </script>

        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />

        <svg id="bargraph" height="500" width="1500">
            <text id="nino">El Ni&#241;o ('97-'98)</text>
        </svg>

        <script>
            d3.csv('annual_average_anomaly.csv')
                .then((data) => {

                    // set up margins
                    const svg = d3.select('svg#bargraph');
                    const width = svg.attr('width');
                    const height = svg.attr('height');
                    const margins = { top: 35, right: 10, bottom: 60, left: 90 };
                    const chartWidth = width - margins.left - margins.right;
                    const chartHeight = height - margins.top - margins.bottom;

                    // create gradient
                    const gradient = svg.append("defs")
                        .append("linearGradient")
                        .attr("id", "line-gradient")
                        .attr("x1", "0%").attr("y1", "0%")
                        .attr("x2", "0%").attr("y2", "100%");
                    gradient.append("stop")
                        .attr("offset", "90%")
                        .attr("stop-color", "red");
                    gradient.append("stop")
                        .attr("offset", "10%")
                        .attr("stop-color", "blue");

                    let chartArea = svg.append('g')
                        .attr('transform', `translate(${margins.left},${margins.top})`);

                    // parse data into Number type
                    console.log(data);
                    data.forEach(d => {
                        d['No Smoothing'] = Number(d['No Smoothing']);
                    });

                    const parseTime = d3.timeParse("%Y");

                    // Turn year into actual dates for making a time scale
                    data.forEach(d => {
                        d.Year = parseTime(d.Year);
                    });

                    const yearExtent = d3.extent(data, d => d['Year']);
                    const changeExtent = d3.extent(data, d => d['No Smoothing']);

                    // create scales
                    const xScale = d3.scaleTime()
                        .domain(yearExtent)
                        .range([0, chartWidth]);

                    const yScale = d3.scaleLinear()
                        .domain(changeExtent)
                        .range([chartHeight, 0]);


                    // create axes and gridlines
                    let bottomAxis = d3.axisBottom(xScale).ticks(d3.timeYear.every(5));

                    svg.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                        .call(bottomAxis);

                    let bottomGridlines = d3.axisBottom(xScale)
                        .tickSize(-chartHeight - 10)
                        .tickFormat('')
                        .ticks(10);

                    svg.append('g')
                        .attr('class', 'gridlines')
                        .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                        .call(bottomGridlines);

                    let leftAxis = d3.axisLeft(yScale);
                    svg.append('g')
                        .attr('class', 'y axis')
                        .attr('transform', `translate(${margins.left},${margins.top})`)
                        .call(leftAxis);

                    let leftGridlines = d3.axisLeft(yScale)
                        .tickSize(-chartWidth - 10)
                        .tickFormat('');

                    svg.append('g')
                        .attr('class', 'gridlines')
                        .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                        .call(leftGridlines);

                    // y-label
                    svg.append("g")
                        .attr("transform", `translate(30, 235), rotate(-90)`)
                        .append("text")
                        .text("Temperature Anomaly from 1977 (C)")
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .style("fill", "black")
                        .style("font-family", "Monaco")
                        .style("font-size", 20)

                    // x-label
                    svg.append("g")
                        .attr("transform", `translate(760, 490)`)
                        .append("text")
                        .text("Year")
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .style("fill", "black")
                        .style("font-family", "Monaco")
                        .style("font-size", 20)

                    // title
                    svg.append("g")
                        .attr("class", "text")
                        .attr("transform", `translate(${width / 2}, ${margins.top / 2})`)
                        .append("text")
                        .text("Global Temperature Anomaly (C) from 1977 to 2022")
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .style("fill", "black")
                        .style("font-family", "Monaco")
                        .style("font-size", 25)

                    // create line
                    svg.append("path")
                        .datum(data)
                        .attr("fill", "none")
                        .attr("stroke", "url(#line-gradient)")
                        .attr("stroke-width", 2)
                        .attr('transform', `translate(${margins.left},${margins.top})`)
                        .attr("d", d3.line()
                            .x(function (d) { return xScale(d['Year']) })
                            .y(function (d) { return yScale(d['No Smoothing']) })
                        )

                    // create points for every datum
                    chartArea.selectAll("circle").data(data)
                        .join("circle")
                        .attr("cx", d => xScale(d['Year']))
                        .attr("cy", d => yScale(d['No Smoothing']))
                        .attr("fill", "purple")
                        .attr("r", 3);


                    // annotations describing events over the years
                    d3.select("text#nino")
                        .attr("x", 730)
                        .attr("y", 230)
                        .style("text-anchor", "middle")
                        .style("font-family", "Monaco")
                        .style("font-weight", "bold");

                    svg.append("text")
                        .text("Eruption of Mount Pinatubo ('91)")
                        .attr("x", 560)
                        .attr("y", 420)
                        .style("text-anchor", "middle")
                        .style("font-family", "Monaco")
                        .style("font-weight", "bold");

                    svg.append("text")
                        .text("The Paris Agreement")
                        .attr("x", xScale(parseTime(2015)) + 120)
                        .attr("y", 85)
                        .style("text-anchor", "middle")
                        .style("font-family", "Monaco")
                        .style("font-weight", "bold");


                    // function to calucate the least squares regression
                    // credited in codesource.js
                    // VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV

                    function leastSquares(xSeries, ySeries) {

                        function sum(curr, prev) { return curr + prev; };

                        const xMean = xSeries.reduce(sum) / xSeries.length;
                        const yMean = ySeries.reduce(sum) / ySeries.length;

                        const ssXX = xSeries.map((d) => { return Math.pow(d - xMean, 2); })
                            .reduce(sum);

                        const ssYY = ySeries.map((d) => { return Math.pow(d - yMean, 2); })
                            .reduce(sum);

                        const ssXY = xSeries.map((d, i) => { return (d - xMean) * (ySeries[i] - yMean); })
                            .reduce(sum);

                        const slope = ssXY / ssXX;
                        const intercept = yMean - (xMean * slope);
                        const rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

                        return [slope, intercept, rSquare];
                    }

                    // given set of data, calculate the least squares and output the trendline
                    const xLabels = data.map((d) => { return d['Year']; })
                    const xSeries = d3.range(0, xLabels.length);
                    const ySeries = data.map((d) => { return d['No Smoothing']; });
                    const leastSquaresCoeff = leastSquares(xSeries, ySeries);

                    const x1 = xLabels[0];
                    const y1 = leastSquaresCoeff[0] + leastSquaresCoeff[1];
                    const x2 = xLabels[xLabels.length - 1];
                    const y2 = leastSquaresCoeff[0] * xSeries.length + leastSquaresCoeff[1];
                    const trendData = [[x1, y1, x2, y2]];

                    // create trendline
                    const trendline = svg.selectAll(".trendline")
                        .data(trendData);

                    trendline.enter()
                        .append("line")
                        .attr('transform', `translate(${margins.left},${margins.top})`)
                        .attr("class", "trendline")
                        .attr("x1", function (d) { return xScale(d[0]); })
                        .attr("y1", function (d) { return yScale(d[1]); })
                        .attr("x2", function (d) { return xScale(d[2]); })
                        .attr("y2", function (d) { return yScale(d[3]); })
                        .attr("stroke", "red")
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", 20, 10);

                    // display the r-squared correlation number
                    svg.append("text")
                        .text("r-sq: " + Math.round(leastSquaresCoeff[2] * 100) / 100)
                        .attr("x", function (d) { return xScale(x2) - 60; })
                        .attr("y", function (d) { return yScale(y2) - 10; })
                        .attr("dominant-baseline", "middle")
                        .attr('transform', `translate(-30 455 ) rotate(-15)`)
                        .attr("class", "text-label")
                        .style("text-anchor", "middle")
                        .style("font-family", "Monaco")
                        .style("font-weight", "bold");

                    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                    chartArea.raise();

                }, (error) => { console.log('error', error); });
        </script>
    </p>
</body>

</html>