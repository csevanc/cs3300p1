<html>
    <head>
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../css/normalize.css">
        <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
        <link rel="stylesheet" type="text/css" href="../css/custom-style.css">
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <title>INFO 3300 - HW 5 - Justin Wong (jsw345)</title>
    </head>
    <body>
        <h1>INFO3300 - HW 5 - Justin Wong (jsw345)</h1>
        <h4> Problem 1</h4>
        <ul id="p1">
           <li> 
            This is a sequential scale because the data does not have a midpoint/neutral middle, 
            and this is an effective sequential color scale because it is accessible as it is easy to distinguish between the lighter white and darker blue colors, i.e. the variation in color is universally perceivable (as checked by Coblis).
           </li>
           <li>
            This scale is is not effective because it is hard to tell the difference between slightly-positive and slightly-negative sentiments, as both sentiments seem to just be light blue if the values are near the middle of the spectrum. 
            Also, it does not seem intuitive to me for positive sentiments to be represented with the color red and negative sentiments to be associated with the color yellow.
           </li>
           <li>
            The trichromatic and dichromatic color vision deficiencies that cause a loss of perceivable hue variation would be blue-weak/tritanomaly and blue-blind/tritanopia.
           </li>
           <li>
            I would recommend this rainbow scale as it seems intuitive to associate more water lost to evapotranspiration with yellow/orange colors and less water lost to evapotranspiration
            with blue/purple colors, however I would suggest that they discretize the scale in the legend of the map/figure so it is easier to associate different colors with a range of numeric values. 
            Also, since this data is county-by-county, this spectrum will nicely illustrate the intensity of a transition if the water lost to evapotranspiration varies drastically or gradually between locations. 
           </li>
        </ul>
        <h4> Problem 2</h4>
        <p id="p2">
            <svg id=s1 height=600 width=600 style="background-color: black"></svg>
            <script>
                d3.csv('NCAA_shots.csv').then( (data) => { 
                    console.log(data)
                    let svg = d3.select("svg#s1")
                    let attemptExtent = d3.extent(data, d => d['log_attempt'])
                    let colorScale = d3.scaleSequential(attemptExtent, d3.interpolatePlasma)
                    
                    svg.selectAll("circle").data(data) // find circles, see if any data associated with those circles (if they exist)
                       .join("circle")
                       .attr("r", 5)
                       .attr("cx", d => d.x )
                       .attr("cy", d => d.y)
                       .attr("fill", d => colorScale(d.log_attempt))


                })
            </script>
            <br />
            <br />
            - One advantage with the logarithmic color scale is that you can actually tell the difference between the frequency of shots that were previously indistinguishable in the linear color scale. 
            <br />
            - One disadvantage is that it is hard to comprehend and gauge the actual difference in the number of attempts between various colors since it is a logarithmic scale.
        </p>
        <h4> Problem 3</h4>
        <p id="p3">
            <svg id=s2 height=420 width=420></svg>
            <br />
            <br />
            <input type="range" id="lightness" name="lightness" min="0" max="200" step="1" />
            <script>
                let svg = d3.select("svg#s2")
                let hc_arr = [];
                for (c_v = 0; c_v <= 100; c_v+=5) {
                    for (h_v = 0; h_v <= 360; h_v+=18) {
                        hc_arr.push({c : c_v, h : h_v})
                    }
                }
                console.log(hc_arr)
                
                let xScale = d3.scaleLinear()
                               .domain([0, 360])
                               .range([10, 410])
                let yScale = d3.scaleLinear()
                               .domain([0, 100])
                               .range([410, 10])

                function showCircles(lightness) {
                    svg.selectAll("circle").data(hc_arr) // find circles, see if any data associated with those circles (if they exist)
                       .join("circle")
                       .attr("r", 10)
                       .attr("cx", d => xScale(d.h))
                       .attr("cy", d => yScale(d.c))
                       .attr("fill", d => d3.hcl(d.h, d.c, lightness))
                       .style("stroke", "none")
                }
                console.log("YOOOO")
                showCircles(100);
                d3.select("input").on("input", (event) => showCircles(event.target.valueAsNumber))
            </script>
        </p>
    </body>
</html>